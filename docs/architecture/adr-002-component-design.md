# ADR-002: Atomic Designパターンの採用

## ステータス
採用済み（2024-04-10）

## 背景
コンポーネントの再利用性、保守性、一貫性を確保するため、効果的なコンポーネント設計パターンが必要でした。
以下の課題がありました：
- コンポーネントの粒度の一貫性
- 再利用可能なコンポーネントの特定
- デザインシステムの体系化
- 開発効率の向上

## 決定事項
Atomic Designパターンを採用し、以下の階層でコンポーネントを構築します：

```
components/
├── atoms/          # 最小単位のコンポーネント
│   ├── Button/
│   ├── Input/
│   └── Text/
├── molecules/      # atomsの組み合わせ
│   ├── FormField/
│   └── Card/
├── organisms/      # 特定の機能を持つ大きな単位
│   ├── Header/
│   └── Footer/
└── templates/      # ページのレイアウト
    └── MainLayout/
```

## コンポーネントの実装規則
1. **型定義**
```typescript
// コンポーネントのpropsは必ず型定義
interface ButtonProps {
  variant: 'primary' | 'secondary';
  size: 'sm' | 'md' | 'lg';
  children: React.ReactNode;
  onClick?: () => void;
}
```

2. **ファイル構造**
```
ComponentName/
├── index.tsx      # コンポーネント本体
├── styles.ts      # スタイル定義（必要な場合）
└── types.ts       # 型定義（複雑な場合）
```

## 代替案の検討
1. **機能ベースの分類**
   - メリット：機能単位での管理が容易
   - デメリット：再利用性が低下

2. **ページベースの分類**
   - メリット：ページ単位での開発が容易
   - デメリット：コンポーネントの重複が発生

## 影響
### メリット
1. **開発効率**
   - 一貫性のある設計方針
   - 再利用可能なコンポーネントの特定が容易
   - チーム間での共通理解

2. **保守性**
   - コンポーネントの責務が明確
   - テストが書きやすい
   - ドキュメント化が容易

### デメリット
1. **学習コスト**
   - 新しいパターンの習得が必要
   - コンポーネントの分類に時間がかかる

2. **オーバーエンジニアリング**
   - 小規模な変更でも構造化が必要
   - 初期の開発速度が遅くなる可能性

## 対策
1. **開発効率の維持**
   - コンポーネントのテンプレート作成
   - Storybookでのドキュメント化

2. **学習コストの低減**
   - コンポーネント設計ガイドの作成
   - コードレビューでの指摘事項の共有

## 注意点
- コンポーネントの責務を明確に保つ
- 過度な抽象化を避ける
- プロジェクトの規模に応じて柔軟に対応 